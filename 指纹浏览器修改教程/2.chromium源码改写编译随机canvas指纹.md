# å¹¿å‘Šä½ï¼š
  [OKKproxxy](https://okkproxy.com/)åŠ¨æ€ä½å®…ä»£ç†IP/æµ·å¤–ç§»åŠ¨IP/é™æ€ä½å®…IPç­‰å‡æœ‰ï¼Œ
  <div style="border: 2px solid #f39c12; padding: 15px; background-color: #fffbe6; border-radius: 10px;">

<details open>
<summary><b>ğŸŒŸ æ¨èä»£ç†ï¼š [OKKproxxy](https://okkproxy.com/)</b></summary>

ğŸ”¥ **OKKproxxy** OKKproxxyæ‹¥æœ‰8000ä¸‡ä¸ªå…¨çƒä½å®…IPï¼Œè¦†ç›–200ä¸ªå›½å®¶

- ğŸš€ **å…æ³¨å†Œä½“éªŒ**ï¼šæ³¨å†Œè”ç³»å®¢æœå‘ŠçŸ¥ä¸ºOKBrowserç”¨æˆ·å³å¯è·èµ 200MåŠ¨æ€æµé‡ã€‚
- ğŸŒ **ä¸šåŠ¡èŒƒå›´**ï¼šåŠ¨æ€ä½å®…ä»£ç†IP/æµ·å¤–ç§»åŠ¨IP/é™æ€ä½å®…IPã€‚
- ğŸ€ **ä»£ç†ç±»å‹**ï¼šæ”¯æŒ HTTP(Sï¼‰SOCKS5 ä»£ç†ã€‚
- ğŸ‰ **é€‚ç”¨ä¸šåŠ¡**ï¼šé€‚ç”¨äºç”µå­å•†åŠ¡ã€ç¤¾äº¤åª’ä½“ã€å¤šå¸æˆ·ã€SEOã€‚
- ğŸ¤ **æˆç«‹æ—¶é—´**ï¼š3å¹´ã€‚

ğŸ”— **è®¿é—®ç½‘ç«™**ï¼š[OKKproxxy](https://okkproxy.com/)

</details>

## æ­£æ–‡
### ä¸€ã€ä»€ä¹ˆæ˜¯canvasæŒ‡çº¹
Canvas æŒ‡çº¹æŠ€æœ¯æ˜¯ä¸€ç§åœ¨ç½‘ç«™è¿½è¸ªç”¨æˆ·è¡Œä¸ºå’Œè¯†åˆ«ç”¨æˆ·èº«ä»½çš„æ–¹æ³•ã€‚
ç½‘ç«™å¯ä»¥è¦æ±‚æµè§ˆå™¨åˆ›å»ºä¸€ä¸ªéšå½¢çš„ç”»å¸ƒï¼Œå¹¶åœ¨è¿™ä¸ªç”»å¸ƒä¸Šç»˜åˆ¶å›¾å½¢ï¼Œä½¿ç”¨æ–‡å­—æˆ–å…¶ä»–è§†è§‰å…ƒç´ ã€‚
ç»˜åˆ¶å‡ºçš„å›¾åƒå¯èƒ½åœ¨åƒç´ çº§åˆ«ä¸Šæœ‰å¾®å¦™çš„å·®å¼‚ã€‚è¿™äº›å·®å¼‚å¯ä»¥ç”¨æ¥ç”Ÿæˆä¸€ä¸ªå‡ ä¹ç‹¬ä¸€æ— äºŒçš„æ ‡è¯†ç¬¦â€”â€”å³æ‰€è°“çš„â€œCanvas æŒ‡çº¹â€ã€‚


### äºŒã€è·å–æµè§ˆå™¨çš„canvasæŒ‡çº¹
æœ‰æ”»æ‰æœ‰é˜²ï¼Œå…ˆçœ‹çœ‹ç½‘ç«™æ˜¯å¦‚ä½•é€šè¿‡jsè·å–ä½ çš„canvasæŒ‡çº¹çš„ã€‚
å°†ä¸‹é¢çš„ä»£ç å¤åˆ¶åˆ°F12æ§åˆ¶å°ï¼Œå°±å¯ä»¥è·å–æ˜¾ç¤ºä½ çš„canvasæŒ‡çº¹äº†ã€‚
```bash
async function sha256(message) {
    // æŠŠå­—ç¬¦ä¸²è½¬æ¢ä¸ºUint8Array
    const msgBuffer = new TextEncoder().encode(message);
    // è®¡ç®—æ•£åˆ—å€¼
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    // è½¬æ¢ä¸ºæ•°ç»„
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    // è½¬æ¢ä¸º16è¿›åˆ¶å­—ç¬¦ä¸²
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

function getCanvasFingerprint() {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    
    // ç»˜åˆ¶ä¸€ä¸ªç®€å•çš„å›¾å½¢ â€”â€” ä¾‹å¦‚ï¼Œæ–‡æœ¬ã€‚
    ctx.textBaseline = "top";
    ctx.font = "14px 'Arial'";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    
    // è®¾ç½®ä¸€äº›canvaså±æ€§ç”¨æ¥å¢åŠ å·®å¼‚æ€§
    ctx.fillStyle = "#069";
    ctx.fillText("Hello World!", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillText("Hello World!", 4, 17);

    // ç»˜åˆ¶æ›´å¤šå¤æ‚çš„ä¸œè¥¿ï¼Œæ¯”å¦‚å˜æ¢æˆ–è€…è·¯å¾„
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    ctx.lineTo(50, 100);
    ctx.stroke();
    
    // å°è¯•è·å–canvaså›¾åƒæ•°æ®
    var data = canvas.toDataURL(); // è·å–å›¾åƒçš„data URL
    
    // åˆ›å»ºä¸€ä¸ªhashå€¼ï¼Œæ¯”å¦‚ä½¿ç”¨SHA256æˆ–å…¶ä»–ç®—æ³•
    return data; // å‡è®¾sha256()æ˜¯ä½ çš„hashå‡½æ•°
}
sha256(getCanvasFingerprint()).then(hash => console.log(hash));


```


è¾“å‡ºï¼š
```bash
62a60d12f6688e2f53425fa4e35d74d2afd61d30e9e1bfe58e47c7abc72bc2d7
```
```bash

```

æ³¨æ„ï¼šå¦‚æœç½‘ç«™é€šè¿‡è·å–äº†ä½ çš„canvasæŒ‡çº¹ï¼Œå°±ç®—é€€å‡ºç™»å½•ï¼Œç½‘ç«™åŸºæœ¬ä¹Ÿèƒ½ç¡®å®šï¼Œè¿™ä¸ªç”¨æˆ·å°±æ˜¯ä½ äº†ã€‚ä¿¡æ¯å°±æ˜¯è¿™ä¹ˆæ³„æ¼çš„ã€‚


### ä¸‰ã€ç¼–è¯‘éšæœºcanvasæŒ‡çº¹
ä¸Šç¯‡æ–‡ç« å†™äº†å¦‚ä½•ç¼–è¯‘chromiumï¼Œå‡è®¾ä½ å·²ç»ç¼–è¯‘æˆåŠŸäº†ã€‚

æ‰¾åˆ°æºç  \third_party\blink\renderer\modules\canvas\canvas2d\base_rendering_context_2d.cc

1.å¤´éƒ¨åŠ ä¸Š(éšä¾¿åŠ åœ¨ä¸€ä¸ª#includeåé¢)
```bash
#include <random>
```


2.æ›¿æ¢æ‰åŸæœ‰ä»£ç 
```bash
void BaseRenderingContext2D::fillText(const String& text, double x, double y) {
  DrawTextInternal(text, x, y, CanvasRenderingContext2DState::kFillPaintType);
}

void BaseRenderingContext2D::fillText(const String& text,
                                      double x,
                                      double y,
                                      double max_width) {
  DrawTextInternal(text, x, y, CanvasRenderingContext2DState::kFillPaintType,
                   &max_width);
}

```


æ›¿æ¢ä¸º
```bash
int getRandomIntForFoo4Modern() {
    static std::mt19937 generator(static_cast<unsigned long>(time(NULL))); // é™æ€ä»¥ç¡®ä¿åªåˆå§‹åŒ–ä¸€æ¬¡
    std::uniform_int_distribution<int> distribution(0, 2);
    return distribution(generator);
}

void BaseRenderingContext2D::fillText(const String& text, double x, double y) {
  x = x + getRandomIntForFoo4Modern();
  y = y + getRandomIntForFoo4Modern();
  DrawTextInternal(text, x, y, CanvasRenderingContext2DState::kFillPaintType);
}

void BaseRenderingContext2D::fillText(const String& text,
                                      double x,
                                      double y,
                                      double max_width) {
  x = x + getRandomIntForFoo4Modern();
  y = y + getRandomIntForFoo4Modern();
  DrawTextInternal(text, x, y, CanvasRenderingContext2DState::kFillPaintType,
                   &max_width);
}
```


getRandomIntForFoo4Modern()å‡½æ•°æ˜¯åœ¨0-2ä¹‹é—´å–ä¸€ä¸ªéšæœºæ•°
ç³»ç»Ÿæ¯æ¬¡è°ƒç”¨fillTextæ—¶åŠ ä¸Šéšæœºåç§»ï¼Œåç§»ä¸å®œå¤ªå¤§ï¼Œä¼šå¯¼è‡´å›¾å½¢æ··ä¹±ã€‚

3.ç¼–è¯‘
ninja  -C  out/Default chrome

æ‰¾åˆ°out/Default chromeä¸‹æ–°ç¼–è¯‘çš„æ‰§è¡Œæ–‡ä»¶chrome.exeæ‰§è¡Œ
å†æ¬¡çœ‹çœ‹canvasæŒ‡çº¹ï¼Œæ˜¯ä¸æ˜¯æ¯æ¬¡è®¿é—®éƒ½å˜æˆéšæœºäº†ã€‚


### å››ã€è¿˜ä¸å¤Ÿéšæœº?
å°†å‡½æ•°BaseRenderingContext2D::measureTextæ›¿æ¢æˆä¸‹é¢çš„ä»£ç 
```bash
TextMetrics* BaseRenderingContext2D::measureText(const String& text) {
  // The style resolution required for fonts is not available in frame-less
  // documents.

  HTMLCanvasElement* canvas = HostAsHTMLCanvasElement();
  if (canvas) {
    if (!canvas->GetDocument().GetFrame()) {
      return MakeGarbageCollected<TextMetrics>();
    }

    canvas->GetDocument().UpdateStyleAndLayoutTreeForElement(
        canvas, DocumentUpdateReason::kCanvas);
  }

  const Font& font = AccessFont(canvas);

  const CanvasRenderingContext2DState& state = GetState();
  TextDirection direction = ToTextDirection(state.GetDirection(), canvas);
  
  //return MakeGarbageCollected<TextMetrics>(
  //   font, direction, state.GetTextBaseline(), state.GetTextAlign(), text);
  
  int tmp = getRandomIntForFoo4Modern();
  String tmp_text;
  if (tmp == 0 && text.length() != 0) {
    tmp_text = text + " ";
  }else{
	tmp_text = text;
  }
  
  return MakeGarbageCollected<TextMetrics>(
      font, direction, state.GetTextBaseline(), state.GetTextAlign(), tmp_text);
}

```

ä¸Šè¿°ä»£ç çš„æ„æ€æ˜¯æ¯æ¬¡æ¸²æŸ“æ–‡å­—æ—¶ï¼Œéšæœºç»™æ–‡å­—è¿½åŠ ä¸€ä¸ªç©ºå­—ç¬¦ã€‚
è¿™æ ·æ¯æ¬¡æµ‹é‡canvaså°ºå¯¸è‚¯å®šå°±æ˜¯éšæœºå•¦ã€‚


### äº”ã€åœ¨çº¿æŒ‡çº¹éªŒè¯ç½‘ç«™ï¼š
https://browserleaks.com/canvas
https://abrahamjuliot.github.io/creepjs/
